# C++内存模型

C++内存模型中的三种内存顺序分别是顺序一致性、松散一致性和严格一致性。

1. 顺序一致性（Sequential Consistency）：顺序一致性是最强的一致性模型，它要求所有线程看到的内存访问顺序是一样的。在顺序一致性的内存模型中，每个线程按照它们在程序中的顺序执行操作，并且所有线程都看到相同的顺序。这意味着在一个线程中观察到的操作顺序，在所有其他线程中也以相同的顺序被观察到。这种一致性模型保证了原子性和可见性，但是它可能会限制一些编译器优化和指令重排序。

2. 松散一致性（Loose Consistency）：松散一致性是一种较弱的一致性模型，它允许一些优化和重排序，但仍然要求程序行为在单个线程内部是一致的。这意味着在一个线程中观察到的操作顺序，在所有其他线程中仍然以相同的顺序被观察到，但是编译器和处理器可以进行一些优化和重排序，只要它们不会导致程序的行为在不同的线程之间不一致。这种一致性模型允许更高的性能，但需要程序员更加小心地处理并发问题。

3. 严格一致性（Strict Consistency）：严格一致性要求所有线程都看到相同的顺序，但不保证操作的重排序。这意味着在一个线程中观察到的操作顺序，在所有其他线程中也以相同的顺序被观察到，而且没有处理器可以对这些操作进行重排序。严格一致性的一致性最强，但也可能限制性能最高。

需要注意的是，不同的处理器架构和操作系统可能具有不同的内存模型实现，因此在实际编程中需要仔细考虑内存模型的细节，并选择适合自己应用程序的一致性模型。

`std::memory_order`是C++标准库中定义的一种枚举类型，用于指定原子操作的内存顺序。它主要用于多线程并发编程中，以控制原子操作之间的内存访问顺序和可见性。

`std::memory_order`有以下几种枚举值：

1. `std::memory_order_relaxed`：最弱的一致性模型，允许原子操作之间的重排序和优化。

2. `std::memory_order_consume`：要求读操作之前的不带锁的写操作与该读操作具有相同的内存顺序可见性。

3. `std::memory_order_acquire`：确保在该原子操作之前的读操作不会被重排序到该原子操作之后。

4. `std::memory_order_release`：确保在该原子操作之后的写操作不会被重排序到该原子操作之前。

5. `std::memory_order_acq_rel`：结合了`std::memory_order_acquire`和`std::memory_order_release`的特性，用于需要读-改-写操作的原子变量。

6. `std::memory_order_seq_cst`：顺序一致性，是最强的一致性模型，要求所有线程看到的内存访问顺序是一样的，并且不允许任何优化和重排序。

通过使用`std::memory_order`，程序员可以在原子操作中指定适当的内存顺序，以确保多线程环境下的正确性和稳定性。例如，可以使用`std::atomic_load<T>(ptr, std::memory_order_relaxed)`来加载一个原子变量，并指定使用松散一致性模型。

## `std::memory_order_consume`

`std::memory_order_consume`是一种内存顺序模型，它是C++11标准中引入的。这个模型主要与“读取-消费”循环（read-consume loop）相关，用于确保在读取一个原子变量之后，其他线程对该原子变量的后续写操作对于当前线程是可见的。

`std::memory_order_consume`的主要目的是解决所谓的“偏斜线程”（skewed threads）问题。这个问题发生在两个线程之间，其中一个线程在循环中读取一个原子变量，而另一个线程在循环中写入该原子变量。如果没有适当的内存顺序规则，第一个线程可能会看到写入操作之间的所有值，而不是写入操作本身的值。

通过使用`std::memory_order_consume`，我们可以确保在读取一个原子变量之后，后续的读操作和写操作之间有一个明确的内存顺序关系。具体来说，当一个线程读取一个原子变量时，它会在该原子变量上设置一个“消费屏障”（consume barrier），这会阻止任何重排序，使得后续的写操作在读取操作之后立即可见。

以下是一个简单的示例，展示了如何使用`std::memory_order_consume`：

```cpp
std::atomic<int> counter(0);

// Thread 1
while (counter.load(std::memory_order_consume) != 0) {
    // do some work...
}

// Thread 2
counter.store(1, std::memory_order_release);
```

在这个示例中，线程1在循环中读取`counter`的值，并使用`std::memory_order_consume`来确保在读取操作之后，其他线程对`counter`的后续写操作对于线程1是可见的。当线程2将`counter`的值设置为1时，它使用`std::memory_order_release`来确保写操作对于线程1是可见的。

需要注意的是，`std::memory_order_consume`是一种相对较弱的内存顺序模型，它只要求读-消费循环中的可见性，而不要求更强的顺序一致性。因此，它可以提供更高的性能，但需要程序员更加小心地处理并发问题。

## Sequenced-before


## Carries dependency


## Synchronizes with


##