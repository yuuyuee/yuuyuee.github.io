# 一致性协议

## 2PC（XA规范）

2PC算法用于使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和一致性。

2PC是针对资源层面的事务操作。关注于多个数据源和数据副本间的同步。

### 角色

协调者（事务管理器），参与者（资源管理器）

### 阶段1：提交事务请求

1. 事务询问

   协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。

2. 事务执行

   参与者执行事务操作，并写Undo和Redo日志。

3. 参与者响应事务询问

   参与者响应协调者事务是否可以执行。

### 阶段2：执行事务提交

根据阶段1中的参与者的响应决定是否最终执行事务提交操作。

* 执行事务提交操作

  1. 发送提交请求

     协调者向参与者发送事务提交请求。

  2. 事务提交

     参与者收到事务提交请求后正式执行事务提交操作。

  3. 反馈事务提交结果

     参与者完成事务提交后像协调者发送ACK消息。

  4. 完成事务

     协调者接受到所有参与者反馈的ACK消息后完成事务。

* 中断事务

  1. 发送回滚请求

     协调者像所有参与者发送rollback请求

  2. 事务回滚

     参与者接受到rollback请求后执行回滚操作。

  3. 反馈事务回滚结果

     参与者在完成事务回滚后，像协调者发送ACK消息。

  4. 中断事务

     协调者接受所有参与者的ACK消息后完成中断事务。

### 优点

简单易实现，对使用者透明。适用于执行时间明确的短事务。。

### 缺点

1. 同步阻塞

   二阶段期间所有参与者处理阻塞状态，无法响应其他任何操作。

2. 单点问题

   调者起到非常重要的作用，一旦协调者出现问题，整个流程将无法继续执行，更严重的是如果二阶段协调者出现问题，所有事务资源将处于锁定状态。

3. 数据不一致

   二阶段如果协调者在发送提交请求后发送网络故障，将导致部分参与者收到提交请求而执行事务的提交，而未收到提交请求则无法执行事务提交，进而导致整体上的数据不一致性。

4. 容错不完善

   参与者故障过程中无法与协调者通讯时，协调者仅能靠超时来判断是否中断事务。

## 3PC

3PC是2PC的改进版，其将二阶段的提交事务请求一分为二，形成了由CanCommit,PreCommit,DoCommit三个阶段。

在协调者和参与者 都引入了超时机制。

参与者在PreCommit阶段如果超时为接受到协调者信息，默认执行提交操作。

### 阶段1：CanCommit

1. 事务询问
2. 各参与者响应协调者事务询问

### 阶段2：PreCommit

* 执行事务预提交请求
  1. 发送预提交请求，进入准备阶段
  2. 事务预提交
  3. 参与者响应协调者事务执行并记录Undo，Redo日志
* 中断事务
  1. 发送中断请求
  2. 中断事务

### 阶段3：DoCommit

* 执行提交
  1. 发送提交请求，进入提交阶段
  2. 事务提交
  3. 反馈事务提交结果
  4. 事务完成
* 中断事务
  1. 发送中断请求
  2. 事务回滚

### 优点

减低了参与者的阻塞范围，针对异常情况，参与者都会在等待超时后，继续进行事务提交。

### 缺点

三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果出现网络分区，此时协调者所在的节点和参与者无法通讯，这种情况下，该参与者依然会进行事务的提交，必然出现数据的不一致性。

## TCC (Try-confirm-cancel)

柔性事务，对业务入侵性高；针对业务/服务层面的操作。

* try: 完成所有的业务检查，预留(锁定)业务资源
* confirm：确认执行业务操作
* cancel：业务最终失败，或者部分业务资源锁定失败，释放已锁定的资源

## paxos

paxos算法是基于**消息传递**且具有**高度容错性**的一致性算法，目前公认解决分布式一致性问题的最有效算法之一。

### 问题描述

对于一组可以提出提案的进程集合来说，一致性算法需要满足以下几点：

* 提出的提案中只有一个会被选定
* 如果没有提出提案则不会有提案被选定
* 一个提案被选定后，进程可以获得被选定的提案信息

安全性

* 只有被提出的提案才能被选定
* 只能有一个值被选定
* 如果某个进程认为某个提案被选定了，那么提案必须是真的被选定的那个

### 参与角色

Proposer - 提案者

Acceptor  - 接受者

Learner    - 学习者

### 推导过程

> P1：一个Acceptor必须批准它收到的第一个提案&提案需要半数Acceptor批准。

> P2：如果编号为M0，值为V0的提案（[M0， V0]）被选定，那么所有比编号M0更高的，且被选定的提案其值也必须是V0。

> P2a：如果编号为M0，值为V0的提案[M0， V0]被选定，那么所有比编号M0更高的且被Acceptor批准的提案，其值必须也是V0。

> P2b：如果一个提案[M0， V0]被选定后，那么之后任何Proposer产生的编码更高的提案其值都为V0。

```
假设某个提案[M0, V0]已经被选定，证明任何编号Mn > M0的提案其值都是V0。
```

> P2c：对于任意Mn和Vn，如果提案[Mn, Vn]被提出，那么肯定存在一个由半数意思的Acceptor组成的集合S，满足一下两个条件中的任意一个。
>
> * S中不存在任何批准过编号小于Mn的提案的Acceptor
> * 选取S中所有Acceptor批准的编号小于Mn的提案，其中编号最大的那个提案其值是Vn

### 如何产生提案

P2c规定了每个Proposer如何产生提案：对于产生的每个提案[Mn, Vn]需要满足以下条件。

存在一个由超过半数的Acceptor组成的集合S：

* 要么S中没有Acceptor批准过编号小于Mn的任何提案
* 要么S中的所有Acceptor批准的所有编号小于Mn的提案中给，编号最大的那个提案的值为Vn

### Proposer生成提案

1. Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合成员发送请求，要求该集合中的Acceptor做出如下 回应。

   * 向Proposer承诺保证不再批准任何编号小于Mn的提案
   * 如果Acceptor已经批准过任何提案，那么其向Proposer反馈当前该Acceptor已经批准的编号小于Mn但为最大编号的那个提案的值。

   我们将请求称为编号为Mn的提案的**Prepare请求**。

2. 如果Proposer收到了来自半数以上的Acceptor的响应，那么它就可以产生[Mn, Vn]的提案，这里的Vn是所有响应中编号最大的提案的值；如果半数以上Acceptor都没有批准过任何提案，即响应中不包含任何提案，那么此时Vn的值就可以由Proposer任意选择。         

   在确定提案后，Proposer将会再次发送提案给Acceptor集合，此请求称为**Accept请求**。          

### Acceptor批准提案

* Prepare请求：Acceptor可以在任何时候响应一个Prepare请求。
* Accept请求：在不违背Accept现有承诺的前提下，可以任意响应Accept请求。

因此，对Acceptor处理逻辑的约束条件为：

> P1a：一个Acceptor只要尚未响应过任何编号大于Mn的Prepare请求，那么它就可以接受这个编号为Mn的提案。
