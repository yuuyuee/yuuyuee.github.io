# 数据复制

复制主要通过在多台服务器上保存相同的副本以达到一下目的。

* 高可用 - 部分节点出现故障，系统依然保持正常运行
* 低延迟 - 将数据存储在地理位置接近用户的地方，从而降低访问延迟
* 可扩展 - 多副本读取，大幅提高系统读吞吐量

## 主从节点复制

[主从复制系统]()

1. 指定一个副本为主副本（或称为主节点）。当客户端写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储。
2. 其他副本全部称为从副本（或称为从节点）。主副本把心数据写入本地存储后，将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志后将其应用到
   本地，且严格保持与主副本相同的写入顺序。
3. 客户端从数据库中读取数据时，可以在主副本或者从副本上执行查询。只有主副本才可以接受写入请求；从客户端角度来看，从副本都是只读的。

### 同步复制与异步复制

[主从复制-同步复制与异步复制]()

* 同步复制
  即主节点需要等待直到从节点确认完成写入后才会向客户端报告完成，并且写入对其他客户端可见。
  
  优点：一旦向客户端确认，从节点可以确保完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。
  缺点：如果同步的从节点无法完成确认，写入就不能视为成功。主节点也会阻塞随后的所有写请求，直到同步副本完成确认。
  
* 半同步复制
  将其中一个从节点设置为同步复制，其他从节点设置为异步复制。当同步从节点故障后将另一个异步复制从节点提升为同步复制。这样可以保证至少有2个节点拥有
  最新的数据副本。

* 异步复制
  即主节点发送完消息后立即返回，不用等待从节点的完成确认。
  
  优点：不管从节点上的数据多么滞后，主节点总是可以继续响应写请求，系统的吞吐性能更好（尤其在从节点数量巨大或分布于广域地理位置）。
  缺点：如果主节点发生失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。这意味着即使向客户端确认了写请求也不能保证数据的持久化。

### 配置新的从节点

1. 在某个时间点对主节点对的数据副本产生一个快照，这样避免长时间锁定整个数据库（快照也是系统备份所必须的）。
2. 将快照拷贝应用到新增的从节点。
3. 新增从节点连接到主节点请求快照之后发生的数据更改日志。
4. 获得日志后，新增从节点应用这些快照之后的所有数据变更，这个过程称之为追赶。接下来可以继续处理主节点上新的数据变化并重复步骤1~4。

### 处理节点失效

#### 从节点失效：追赶式恢复

在从节点崩溃重启或主从间发生网络中断恢复时，从节点根据故障发生前最后一个事务请求主节点自这个事务后的所有数据变更，收到这些数据变更日志后
将其应用到本地存储来追赶主节点。滞后合正常情况一样持续接受来自主节点的数据流的变化。

#### 主节点失效：节点接环

选择某个从节点将其提升为主节点，客户端也需要更新，这样之后的写请求也会发往新的主节点，然后其他从节点要接受来自新的主节点上的变更数据，这个
过程称之为切换。故障切换可以是手动的或者是自动的，自动切换步骤如下：

1. 确认主节点失效
   大多数系统采用基于超时的故障检测机制，节点间频繁互相发送心跳存活消息，如果发现某个节点在一段比较长时间内（例如 30s）没有响应，即认为该节点
   失效。
2. 选举新的主节点
   通过选举的方式（超过半数节点达成共识）来选举新的主节点或者指定新的主节点。候选节点最好与主节点数据差异最小，这样可以最小化数据丢失风险。
   让所有节点同意新的主节点是个典型的**共识**问题。
3. 重新配置系统是新的主节点生效
   客户端现在需要将写请求发给新的主节点（请求路由）。确保原主节点恢复后降级为从节点并认可新的主节点。

节点切换过程中可能出现的问题：

1. 如果使用异步复制时，新主节点可能并未完全完成接受到原主节点上的数据变更，在原主节点失效，节点切换后，新主节点数据滞后于原主节点，随后的
   写请求同步会造成写冲突。常见的方案是原主节点丢弃未完成复制的写请求，但这也会造成数据都是，违背数据库更新持久化的原则。而且如果数据库与其他
   依赖数据库的系统（例如缓存）协同工作时，丢弃数据的方案将变得更危险（比如数据泄露）。
2. 通过共识来选举新的主节点可能发生两个节点同事都自认为是主节点，这种情况称之为脑裂。两个主节点都可能接受写请求，并且没有很好的办法解决冲突，
   最终可能发生数据丢失或损坏，一种应急方案是强制关闭其中一个主节点（隔离）。
3. 如何设置合适的超时时间来检测主节点失效：超时时间越长意味着总体恢复时间越长。超时时间太短则会发生许多不必要的节点切换。突发的负载峰值或网络故障
   会导致响应时间变长甚至超时，而系统本身的高负载或网络的拥塞加上节点切换只会使总体情况更糟。

***节点失效，网络不可靠，副本一致性，持久性，可用性与延迟之间的各种细微权衡实际上正是分布式系统核心的基本问题***

### 复制日志的实现

#### 基于语句的复制

主节点记录所执行的写请求并将操作语句（例如SQL)发送给从节点，从节点分析并执行这些语句。这种复制方式面临以下问题：

1. 任何调用非确定性函数的语句，例如NOW()获取当前时间，在不同副本上会产生不同的值。
   有的数据库会记录语句中的不确定性函数并替换为执行后确定的值，而有的数据库则会在遇到不确定性函数时切换复制方式。
2. 如果使用自增列或依赖于数据库现有数据的语句时，所有副本必须严格按照相同的顺序执行，否则会产生不同的结果。进而如果多个同时并发执行的
   事务时，会有很大的限制。
3. 有副作用的语句（例如触发器，存储过程，用户自定义函数）在不同副本上可能产生不同的副作用。

考虑以上因素，基于语句的复制通常不是首选的复制实现方案。

#### 基于预写日志WAL的复制

所有对数据库的写入都会先行写入预写日志（主要用于失败恢复），主节点还可以将其发送给从节点来实现复制。这种复制方式面临以下问题：

1. 预写日志通常描述底层数据接结果，使得复制方案与存储引擎紧耦合。
2. 如果数据库的存储格式发生改变将导致无法再节点上运行不同版本的数据库。

#### 基于行的逻辑日志的复制

采用与特定存储引擎不同的日志格式以解耦存储引擎与日志间的耦合，这种复制日志称之为逻辑日志。关系型数据库中逻辑日志指一系列记录来描述
行级别的写请求：
* 对于插入，日志包含相关列的新值
* 对于删除，日志包含足够信息用来标识已删除的行。如果有主键则使用主键，否则则记录所有列值。
* 对于更新，日志包含足够信息用来标识更新的行以及更新列的新值。
* 对于涉及多行修改的事务，则产生多条以上日志并记录事务已提交。

对于应用程序来说，逻辑日志更容易解析，如果需要发送到离线系统，或缓存等外部系统也更具优势。

#### 基于触发器的复制

以上复制方案都是局域数据库系统来实现的，不涉及任何应用程序。但有时候需要一些高度灵活的复制方案。比如仅复制一部分数据，或者从一种数据库复制到
另一种数据库，或者需要定制管理冲突解决逻辑。可以通过应用程序读取数据库日志来获得数据变更，也可以借助大多数关系型数据库都支持的功能：触发器和
存储过程。触发器支持用户自定义应用层代码，使得当数据库数据变更时执行自定义代码。基于触发器的复制方法通常比其他复制方法开销更高，也比数据库内置
复制方法更容易出错或暴露一些限制，但其高度灵活性使其任有用武之地。

### 复制滞后问题

### 复制滞后的解决方案

## 多主节点复制

## 无主节点复制
