# 数据处理与检索

## OLTP vs OLAP

| 属性   | OLTP         | OLAP           |
| :--- | :----------- | :------------- |
| 读特征  | 基于键，每次返回少量记录 | 对大量记录进行汇总      |
| 写特征  | 随机访问，低延迟写入   | 批量导入（ETL）或事件流  |
| 使用场景 | 终端用户通过应用程序访问 | 内部分析决策使用       |
| 数据表征 | 最新的数据状态      | 随着事件变化而变化的事件历史 |
| 数据规模 | GB-TB        | TB - PB        |

## OLTP - 在线事务处理

* 面向用户，接受大量的请求
* 存储引擎使用索引查找所查询的数据记录
* 每次查询通常只涉及少量记录
* 磁盘寻址时间是瓶颈

## OLAP - 在线分析处理

* 面向业务分析，接受少量请求
* 每次查询需要在短时间内扫描大量记录并仅读取少数几列
* 磁盘带宽是瓶颈
* 大量的行扫描时索引的关联性显著降低，而更紧凑的编码数据可以减少磁盘读取量

## 存储引擎

高效的查询数据库中的特定键的值需要**索引**，索引是基于原始数据派生而来的额外数据结构，各种索引背后的基本思想都是保留一些额外的元数据，把这些元数据做为数据的标记帮助定位；针对不同的搜索方式搜索相同数据可以定义多种不同的索引。索引涉及存储系统中重要的权衡设计，即适当的索引可以加速读取查询，但每次写入时都需要更新索引，因此任何类型的索引都会降低写入速度。

### 内存哈希存储引擎

键值数据存储全部以追加的方式写入文件；将数据的键及数据的值在文件中的偏移位置存储在内存中的哈希表中。写入时：将键值写入日志文件并更新内存中的哈希表；读取时：通过键查询值在文件中的偏移位置，然后读取其内容。

当日志文件到达一定大小，关闭当前日志文件并不再修改，后续数据将被写入到新的日志文件中，然后可以在已关闭的日志文件上执行压缩，即丢弃重复键值并只保留最新键值。压缩使得日志文件更小，还可以在执行压缩过程中将多个日志合并在一起，由关闭的日志文件不会被修改，所以压缩合并后的数据将被写入新的日志文件中，这些操作均在后台线程中完成并且同时旧的日志文件依然提供正常的读写请求。压缩合并后写请求将切换到新的日志文件中，就的日志文件可以安全的删除。

每个日志文件都有自己的哈希表，将键映射到文件的偏移位置。读取时首先查询最新的哈希表，如果不存在则一次检查旧的哈希表，由于压缩合并的存在，通常只会维持少量的日志文件，因此不会查询很多哈希表。

这类存储引擎适合键全部存储在内存中可行并且频繁写入更新的场景，因为只需要一次磁盘寻址（如果日志文件已经在文件系统中的缓存里，则不需要任何磁盘I/O），可以提供高性能的读和写。追加和分段日志文件主要是顺序写，相比于随机写快得多，特别是对于机械硬盘，并且某种程度上即使是SSD也是合适的；日志文件是关闭后是不可变的，在并发和崩溃恢复要简单得多，不会发生崩溃后新旧数据混在得情况；合并压缩旧得日志文件也避免了随着时间推移日志文件得碎片化问题。

局限性：

* 哈希表必须全部放入内存，无法应对大量键的场景（即使考虑将哈希表存储到磁盘上，大量随机I/O和哈希冲突都是代价昂贵的）。
* 哈希表的无序性导致只能逐个查询而不能区间查询。

实现中的一些重要问题：

* 文件格式

  二进制格式是最适合的日志文件格式。

* 删除记录

  删除数据在日志文件中追加一条特殊的数据（这里成为墓碑），当合并压缩时遇到墓碑标记则丢弃已经删除数据的所有值。

* 崩溃恢复

  数据库崩溃重启后，最简单的方式是读取所有日志文件来重建哈希表，但如果日志文件很大时读取时间可能很长，使得重启变得缓慢。通过为每个日志文件建立哈希表快照并存储在磁盘上来加快恢复速度。

* 部分数据写入

  为每个键值提供校验值可以发现损坏的部分并丢弃。

* 并发控制

  由于写入以严格的先后顺序追加到文件，通常只有一个写线程。日志文件是追加的并且不可变的，所以可以被多个线程同时读取。

代表产品：BitCask，Dynamo，Beansdb（gobeansdb）

### 日志结构存储引擎 LSM-Tree

基于合并和压缩排序文件原理的存储引擎通常都被成为LSM存储引擎，最早出现在日志结构文件系统中使用。

类似于内存哈希表存储引擎，这里有一些不同，日志文件格式（SSTable），要求键值对按键排序，并且每个日志文件中每个键只出现一次，合并时即使文件大于内存也可采用类似合并排序算法并发读取多个日志文件比较每个文件的第一个键把最小的键写入新的日志文件中，当遇到重复的键时最新的日志文件中的键通常时最新的值。内存索引采用诸如红黑树或AVL树，这些数据结构可以按任意顺序插入键并顺序读取。内存索引可以是稀疏的，不需要把所有的键保存在内存中。由于内存索引指向的是范围数据，可以将其压缩保存到一个块中以降低磁盘空间，压缩还减少了磁盘I/O带宽。

写入时，将其添加到内存中的平衡数数据结构（内存表）中。当内存表到达某个阈值时，将其作为SSTable文件写入磁盘，新的SSTable文件成为数据库的最新部分，同时写入可以继续添加到一个新的内存表中。读取时，首先在内存表中查询键，然后到最新的磁盘日志文件依次查找，直到找到目标。后台线程周期执行日志文件合并于压缩并丢弃那些覆盖或删除的值。如果数据库崩溃，最近写入（在内存表但尚未写入磁盘）的数据将会丢失，这里可以在磁盘上保留单独日志，每次写入都会立即追加到该日志，此日志不需要按键排序，它的唯一目的就是在崩溃后恢复内存表，当内存表写入SSTable后相应日志即可丢弃。

读取时需要先查询内存表，在依次查询最旧的日志文件，如果查询的键不存在，则查询可能很慢， 这里引入布隆过滤器以节省不必要的读取。

SSTable的压缩和合并的具体顺序和时机分为大小分级和分层压缩。大小分级压缩即较新的和较小的SSTable被连续合并到较旧和较大的SSTable中。分层压缩即键的范围分裂为多个小的SSTable，旧数据被移动到单独层级，这样压缩可以逐步进行并节省磁盘空间。

LSM-Tree即使在数据集远大于可用内存时任然可以正常工作，由于数据排序存储，可以执行区间查询，并且由于磁盘时顺序写入的，可以支持非常高的写入吞吐量。

### 面向页的存储引擎 B-Tree

B-Tree是使用最广泛的索引结构，几乎所有关系型数据库中的标准索引实现，许多非关系型数据库也经常使用。其保留了按键排序的键值对弓能，可以实现高效查询和区间查询。不同的是B-Tree将数据库分解为固定大小的页（通常为4K，有时更大），页是内部读写的最小单位，这种设计更接近底层硬件，磁盘也是以固定大写的块排列。每个也使用地址标识，以这些页来构造一个B-Tree，其分支因子的大小决定存储空间总量（分支因子为500的4K页高度为4可以存储高达256TB数据）。

B-Tree写入时使用新数据覆盖磁盘上的旧页，不改变磁盘存储位置，即所有对该页的引用保持不变。某些操作可能需要覆盖多个页，即如果写入导致页溢出，则需要分裂页，那么需要写两个分裂页并且覆盖父页以更新对两个子页的引用。这里可能在部分页写入后崩溃进而导致索引被破坏，常见的B-Tree实现中需要额外的预写日志（WAL，write-ahead log）也称为重写日志，这中日志仅支持追加修改，每个B-Tree的修改必须先写WAL在修改树本身的页，崩溃恢复时，WAL将B-Tree恢复到最近一致的状态。如果多线程同时访问B-Tree，则需要使用并发控制来保护数据结构。一些实现不适用覆盖页和维护WAL来进行崩溃恢复，而是使用写时复制方案，即修改的页被写入不同的位置，树中的父页的新版本被创建并指向新的位置，这个方法对并发控制很有帮助（快照隔离&可重复读）。

页可以存储在磁盘任意位置，不要求相邻页需要存储在相邻位置。如果查询需要顺序扫描大段的键范围，考虑到每个页的读取都可能需要磁盘I/O，逐页的布局可能是低效的。因此许多B-Tree的实现尝试对树进行布局，以便相邻子页可以按顺序存储在磁盘上，然而随着树的增长，维持这个顺序可能变得越来越困难。

额外的前驱后继指针也可在顺序扫描时不用跳回父页。而其他一些变体（例如分形树）则借鉴了日志结构的一些想法来减少磁盘寻址。

### B-Tree vs LSM-Tree

LSM-Tree通常写入更快而B-Tree则是读取更块。

因为B-Tree索引一次写操作至少需要写两次数据，一次预写日志，一次写树的页本身，即使只修改几个字节，页必须承受整个页的开销。而LSM-Tree由于需要反复压缩和SSTable合并，日志结构索引页会重复写数据多次，这种影响（一次写操作导致多次磁盘写）被称为写放大，对于SSD因为擦写次数有限因而格外关注。大量写密集的应用程序的瓶颈在于写入磁盘的速度，写入磁盘次数越多，可用磁盘带宽中每秒可以处理的写入越少。LSM-Tree比B-Tree具有更高的写入吞吐量的部分原因就在于LSM-Tree具有更低的写放大，部分原因则是它是顺序写入紧凑的SSTable文件而不必重写树中的多个页，这种差异在机械硬盘上尤为明显（顺序写快于随机写）。LSM-Tree因为可以支持压缩并定期重写SSTable以消除碎片化，特别在使用分层压缩时具有更低的存储开销。

也是因为LSM-Tree的压缩过程有时候会干扰正在进行的读写请求，即使时增量执行压缩并且不影响并发访问，但由于磁盘吞吐量有限，在执行昂贵的压缩操作时，很容易引发读写请求等待，这对吞吐量和平均响应时间影响很小，但高位查询时间有时会相当高，而B-Tree的响应延迟则更具有确定性。B-Tree每个键恰好唯一对应索引中的某个位置，而LSM-Tree则不同日志文件中具有相同键的多副本。如果需要支持强大的事务语义，锁可以直接定义到树中。

### 对比内存数据库

内存数据库的优势并不在于其不需要读取磁盘，而是其免于用写磁盘的格式来对内存数据结构编码的开销；内存数据库架构可扩展支持远大于可用内存的数据集并且其支持许多磁盘存储无法支持的数据结构。
