```markdown
* 向前兼容 - 较新的代码能够读取旧代码写的数据
* 向后兼容 - 较旧的代码能够读取新代码写的数据
```

# 数据编码

## 语言特定的格式

许多编程语言都内置支持将内存中的对象编码为字节序列。例如java的```java.io.Serializable```， Ruby的```Marshal```，Python的```pickle```。

* 编码通常与特定编程语言绑定，使得另一种语言访问数据非常困难。
* 为了在相同的对象类型中恢复数据，解码过程需要能够实例化任意类，进而导致安全问题。
* 这些库主要设计目的是快速且简单地编码数据，缺乏性能和向前向后兼容性。

## 语言无关的标准格式

### 文本格式

JSON XML和CSV都是文本格式，优点是可读性。JSON XML和CSV在作为数据交换格式的场景下非常广泛，只要就格式本身达成一致，格式多么美观和高效往往不太重要，让不同组织达成格式一致的难度通常超过所有问题。

* 数字编码有很多模糊之处。XML和CSV无法区分数字和由数字组成的字符串；JSON区分字符串和数字，但不区分整数和浮点数，并且不指定精度。
* JSON和XML对Unicode字符串有很好的支持，但不支持二进制字符串。
* JSON和XML都有可选的模式支持。
* CSV没有任何模式或者说是一种模糊的模式，如果文本中出现分隔符将出现不能解析现象。

### 二进制格式

对于组织内部使用的数据，使用统一编码格式则最好。二进制格式更紧凑且解析速度更快，这对于大规模TB级数据影响很大。

#### JSON XML二进制格式

JSON二进制编码格式: MessagePack[^1], BSON, BJSON, UBJSON, BISON

[^1]:[MessagePack 编码格式](http://i5ting.github.io/msgpack-specification/)

XML二进制编码格式：WBX, Fast Infoset

以上格式因为没有规定模式，所以需要在编码数据时包含了所有对象字段的名称。MessagePack二进制编码长度为66个字节，仅比文本编码（去掉空格）少15个字节，如此小的空间缩减付出可读性的代价是否值得任待商榷。

#### Thrift与Protocol Buffers

Apache Thrift和Protocol Buffers是基于相同原理的两种二进制库。

##### 数值压缩

* Variant - variant是一种数值编码，数字越小，存储所需字节越少
数值被被以7位分割，高位补1表示后续字节仍是数值的一部分，补0表示数值编码结束，采用低字节补齐到高字节。
示例： 300 = 0000 0000 0000 0000 0000 0001 0010 1100
编码：1010 1100 0000 0010

* Zigzag - 用于将有符号数映射到无符号数的一种方法，以解决Variant编码负数效率低的问题
编码时候将数值循环左移1位，解码时将数值循环右移1位。
32位Zigzag编码： ```Nzigzag = (N << 1) ^ (N >> 31)```
32位Zigzag解码： ```N = (Nzigzag >> 1) ^ -static_cast<int32>(Nzigzag & 1)```
64位Zigzag编码： ```Nzigzag = (N << 1) ^ (N >> 63)```
64位Zigzag解码： ```N = (Nzigzag >> 1) ^ -static_cast<int64>(Nzigzag & 1)```

##### 接口定义语言

PB和Thrift都是语言无关的，通过接口定义语言（IDL）来定义模式，通过代码生成工具生成支持多语言的类。应用程序通过调用生成的类来编码或解码该模式的数据。

##### 字段标签和数据类型与模式演化

字段使用标签号标识，这对编码数据的含义至关重要。可以轻松改变模式中的字段名称而编码永远不直接引用字段名称（但不能改变随意改变字段标签）。

添加新字段时，给字段添加新的标签号，旧的代码读取新的编码数据可以简单的忽略掉未知标签号从而实现向前兼容。

只要标签号不变，新的代码总是可以读取就的数据的。其中需要注意的时添加的新字段无法使其成为必需字段。

数据类型的修改可能导致丢失精度或被阶段的风险。

#### Avro

Avro也使用模式指定编码的数据结构，支持Avro IDL和基于JSON的两种模式语言。

Avro是所有编码中最紧凑的，它没有标识字段和数据类型，编码是一系列连在一起的值组成的（字符串有长度前缀），解析时，按照模式中的顺序遍历这些字段，只有在读写模式匹配时才能解码数据。

Avro模式分为写模式和读模式，Avro的关键思想是：写模式和读模式只需保持兼容，不必完全一样。当解码时，为了解决读模式与写模式的差异，Avro通过对比读模式与写模式，并将数据从写模式转换为读模式[^2]。

[^2]: [Avro模式解析](https://avro.apache.org/docs/current/spec.html#Schema+Resolution)

Avro为了保持兼容性，只能添加删除具有默认值的字段。添加没有默认值的字段，新的reader无法读取旧的writer写的数据，破坏了向后兼容性；删除没有默认值的字段，旧的reader无法读取新的writer写的数据，破坏了向前兼容性。

Avro中如果字段类型时可转换的，就可以改变字段的数据类型而不破坏兼容性。修改字段名称（通过字段别名）是向后兼容的，但不能向前兼容；向联合类型添加类型也是向后兼容的，但不能向前兼容。

当文件保存记录时，Avro把写模式写道文件头中以用于reader读取记录；当记录保存到数据库中，单独维护模式版本列表，reader可以通过模式版本号来读取数据；通过网络发送记录时可以在建立连接时协商模式版本，并在连接的生命周期内使用该模式。

Avro不同于PB和Thrift，它不包含任何标签，这对于动态生成的模式更友好。这种动态生成模式的能不是PB和Thrift的设计目标，而是Avro的设计目标。

## 模式的优点（总结）

JSON, XML, CSV等文本的，无模式/读时模式有其简单性，灵活性，可读性；PB和Thrift则通过支持演化具备了其灵活性，并在大规模数据场景上表现更加；Avro则在数据紧凑和动态生成模式方面做到了极致。

# 数据流模式

## 基于数据库的数据流

* 数据编码

  在数据库中，写入数据库的进程对数据进行编码，读取数据库的进程进行解码。此间向前向后兼容时必要的，否则会出现旧的数据无法被新的读者解码或则新的数据无法被旧的读者读取。

* 添加字段

  理想的行为通常时旧代码即使无法解析也要保持新字段不变。例如，在将数据库中的数据解码为程序中的模型对象，然后重新编码这些模型对象时，该转换过程可能会导致丢失未知字段。添加的字段通常是具有默认值的空列，读取旧数据为其填充默认值，否则可能需要把旧数据迁移到新模式，这在大型数据集上执行代价昂贵。总的来说数据库虽然底层数据包含多版本，但其模式演化使其看上去采用的是单一模式编码。

* 数据备份/快照

  当需要对数据库中的数据备份或创建快照时，最好对数据副本进行统一的编码，并且由于数据转储后是不变的，因此使用向Avro对象容器文件这样的格式非常合适，这也是使用分析友好的列存储对数据进行编码的好时机。

## 基于服务的数据流：REST和RPC

对于需要通过网络进行通讯的进程，有多种不同的通讯方式。可能是客户端通过网络公开API（HTTP, URL, SSL/TLS, HTML）与服务端通讯，也可能是服务端与服务端通讯。当一个服务需要向另一个服务发起请求时，这种构建应用的方式被称为面向服务体系架构(SOA)，又或称之为微服务架构。服务类似于数据库，允许客户端提交数据和查询。但服务公开了访问其所需要的输入输出，提供了一定程度的封装，对客户端行为施加了细粒度的控制。面向服务/微服务架构的一个关键目标就是通过使服务可独立部署和演化，让应用程序更易于更改和维护。

REST不是一种协议，而是一种基于HTTP原则的设计理念。它强调简单的数据格式，使用URL来标识资源，并使用HTTP功能进行缓存控制，身份验证和内容类型协商，根据REST原则设计的API称为RESTful API。RESTful API有许多显著的优点，利于调试，支持所有主流编程语言和平台，并且拥有庞大的工具生态系统，其主要用于提供公共API，通常使用JSON用于响应，请求则使用JSON或URI编码请求参数，为了保持兼容性，通常考虑的更改包括添加可选的请求参数和在相应中添加新的字段，更复杂的接口还需要在URL或HTTP Accept头中使用版本号来做API版本管理。RPC框架主要侧重于同一组织内多个服务见的请求。RPC的方案的兼容性取决于其使用的编码技术，如果RPC用于跨组织边界的通讯，则服务的兼容性会变得更加困难，因为服务无法控制其客户端，也不能强制其升级。

## 基于消息传递的数据流

* 如果接收方不可用或过载，可以充当缓冲区从而提高系统可靠性
* 自动将消息重发至崩溃的进程从而防止消息丢失
* 避免发送方知道接受方大的IP和端口
* 支持将一条消息发送多个接收方
* 逻辑上解耦发送方与接收方
* 消息传递时单向的，发送者不等待消息被传递或接收者的恢复，不强制使用特定数据模式。

